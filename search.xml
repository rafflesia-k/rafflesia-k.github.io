<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第六章 查询处理和优化</title>
      <link href="/2024/06/28/49d65152.html"/>
      <url>/2024/06/28/49d65152.html</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-查询处理和优化"><a class="markdownIt-Anchor" href="#第六章-查询处理和优化"></a> 第六章 查询处理和优化</h1><p>主要内容：理解常用数据库物理层执行模型；物理层执行过程的数据访问方法；核心逻辑算子的物理执行算法。</p><ol><li>基本要求</li></ol><p>a）理解常用数据库物理层执行模型</p><p>b）熟悉数据库物理层对各逻辑算子的具体执行算法</p><p>c）掌握同种逻辑算子多种物理实现策略的异同和适合的场景</p><ol start="2"><li>重点、难点</li></ol><p><strong>重点：</strong> 数据库物理层对各逻辑算子的具体执行算法</p><p><strong>难点：</strong> 掌握同种逻辑算子多种物理实现策略的异同和适合的场景</p><p>主要内容：数据库SQL引擎中的编译过程，统计信息获取，查询优化（包括基于代价的优化和基于规则的优化）。</p><ol><li>基本要求</li></ol><p>a）了解SQL编译过程中的抽象语法树生成</p><p>b）熟悉查询优化的基本步骤</p><p>c）掌握基于规则的优化和基于代价的优化的区别和联系</p><p>d）掌握基于代价的优化和数据库统计信息间的关系</p><p>e）熟悉查询优化过程中连接顺序剪枝和过滤算法</p><ol start="2"><li>重点、难点</li></ol><p><strong>重点：</strong> 查询优化的基本步骤</p><p><strong>难点：</strong> 基于代价的优化及连接顺序剪枝算法。</p><img src="/2024/06/28/49d65152/image-20240620163927813.png" alt="image-20240620163927813" style="zoom:50%;"><p>查询优化，一般从<font color="red"><mark>逻辑</mark></font>和<font color="red"><mark>物理</mark></font>两个层面进行。逻辑层面优化的目标是<font color="red">找出与原始查询等价但更加高效的关系代数表达式</font>，主要是通过调整关系代数运算顺序来使每步运算要处理的数据行数最少。例如数据库一般会将选择运算下推，以尽早缩减参与运算的数据行数。逻辑优化后需要进行物理优化，<font color="red">主要是利用数据库的数据规模(如数据块大小和统计信息等)来估计计划执行的代价，并从众多候选计划中 出代价最小的计划</font>。物理优化需要选择每个算子的物理实现算法，例如在连接操作中选择嵌套循环连接或哈希连接，并确定多表连接时的连接顺序。查询优化使数据库尽量选择较为高效的执行方案，从而提高数据库执行查询的效率。与逻辑优化不同的是，物理优化过程需要考虑关系实例的统计信息特征，例如一列非重复值的数量，以准确计算不同物理操作的执行代价。</p><img src="/2024/06/28/49d65152/c3fd84168ac6372b1dd9b58d071bae23_720-17189046739911.jpg" alt="img" style="zoom:67%;"><h1 id="一-查询解析"><a class="markdownIt-Anchor" href="#一-查询解析"></a> 一、查询解析</h1><p><img src="/2024/06/28/49d65152/image-20240616170712558.png" alt="image-20240616170712558"></p><h4 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h4><img src="/2024/06/28/49d65152/image-20240616161801986.png" alt="image-20240616161801986" style="zoom:67%;"><p>将输入的SQL语句拆解为单词（token）序列，并对不同类别的单词进行分类标记，形成字符标记流。</p><p>​正则表达式：➢ 标识符ID [a-z][a-z0-9]+</p><p>​➢关键词 Keyword select | from | where</p><p>​➢分隔符 SEP , | ;</p><p>​➢运算符 OP = | + | &lt;</p><p>​➢ INT [0-9]+</p><p>​有限状态自动机</p><img src="/2024/06/28/49d65152/94b29d9db777175fbb2fa245482122f5_720.jpg" alt="img" style="zoom:40%;"><h4 id="语法分析"><a class="markdownIt-Anchor" href="#语法分析"></a> 语法分析</h4><p>移进：将字符标记放入栈中</p><p>归约：用非终结符代替栈的顶部元素  出栈 并在AST中新建对应的语法类节点</p><p><img src="/2024/06/28/49d65152/image-20240616163606648.png" alt="image-20240616163606648"></p><h4 id="语义分析"><a class="markdownIt-Anchor" href="#语义分析"></a> 语义分析</h4><p>检查关系（表名）、属性（列名）、数据类型.......</p><p>授权检查</p><p>将语法分析树转换为查询树</p><h2 id="二-逻辑重写"><a class="markdownIt-Anchor" href="#二-逻辑重写"></a> 二、逻辑重写</h2><p>声明式的SQL-&gt;查询执行的逻辑顺序</p><p>基于规则的优化（Rule-based Optimization, RBO）</p><p>➢ 查询的逻辑重写，以尽可能减少不合理的开销</p><p>➢ 基于（<font color="red">关系代数的等价变换</font>） 规则</p><p>➢ 调整操作顺序</p><p>➢ 生成：由逻辑运算符组成的逻辑计划（树）</p><p>➢ 逻辑运算符：关系代数的算子（π ， σ ， ⋈， …）</p><p>➢ 与关系实例无关</p><p><img src="/2024/06/28/49d65152/image-20240616172747121.png" alt="image-20240616172747121" style="zoom:33%;"><img src="/2024/06/28/49d65152/image-20240616172821178.png" alt="image-20240616172821178" style="zoom:50%;"></p><p><strong>RBO通用规则：</strong></p><ol><li><p>复合谓词拆分</p><p><img src="/2024/06/28/49d65152/image-20240616173118490.png" alt="image-20240616173118490" style="zoom:33%;"><img src="/2024/06/28/49d65152/image-20240616172947051.png" alt="image-20240616172806514" style="zoom:50%;"></p></li><li><p>谓词下推</p><p><img src="/2024/06/28/49d65152/image-20240616173221792.png" alt="image-20240616173221792" style="zoom:49%;"><img src="/2024/06/28/49d65152/image-20240616173244626.png" alt="image-20240616173244626" style="zoom:59%;"></p></li><li><p>笛卡尔积改为连接</p><p><img src="/2024/06/28/49d65152/image-20240616173444040.png" alt="image-20240616173444040" style="zoom:50%;"><img src="/2024/06/28/49d65152/image-20240616173453691.png" alt="image-20240616173453691" style="zoom:50%;"></p></li><li><p>投影下推  ：先过滤掉不必要的列，只携带必需的列进行计算和传递</p></li><li><p>嵌套查询</p><p>重写(为连接查询)【 ref., 视图消解】</p><p>实体化临时表【 ref., 实体化视图】</p></li><li><p>表达式重写</p></li></ol><h2 id="三-物理算子"><a class="markdownIt-Anchor" href="#三-物理算子"></a> 三、物理算子</h2><p>算子：选择、连接、排序、聚集等</p><p>基于代价的优化（Cost-based Optimization, CBO）</p><p>➢ 查询的<font color="red">物理优化</font></p><p>➢ 使用代价模型，对操作进行代价估计</p><p>➢ 衡量所有可能的执行方式，选择执行代价最小的</p><p>➢ 生成：由物理操作符组成的物理执行计划（树）</p><p>➢ <mark>物理操作符</mark>：关系代数算子的具体物理实现 <font color="red">（1 -&gt; n映射）</font></p><p>➢ 与关系实例相关</p><p>➢ 需要使用实例的统计信息</p><p>设<font color="red">B(R)</font>为关系R的块（页）数， <font color="red">T(R)</font>为关系R中的元组数</p><p>例如B(R)=2000， T(R)=100000， (80B/tuple)</p><h4 id="选择σ"><a class="markdownIt-Anchor" href="#选择σ"></a> 选择σ</h4><h5 id="全表扫描-table-scan"><a class="markdownIt-Anchor" href="#全表扫描-table-scan"></a> 全表扫描 Table Scan</h5><p>顺序扫描整个Table，依次检查每个元组以衡量是否满足过滤谓词</p><p>➢ 等值谓词 “ = ”</p><ul><li>对应属性是码/唯一约束（只有一个）时，命中即可结束，<font color="red">平均B(R)/2</font></li><li>代价是<font color="red">B(R)</font></li><li>最多<font color="red">B(R)</font>次I/O操作</li></ul><p>➢比较谓词 “ &lt;, &gt;, ≤, ≥ ”</p><ul><li><font color="red">B(R)</font>次I/O操作</li></ul><h5 id="索引扫描-index-scan"><a class="markdownIt-Anchor" href="#索引扫描-index-scan"></a> 索引扫描 Index Scan</h5><p>借助索引的扫描（索引-&gt;Table），设树深为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mrow><mo fence="true">⌈</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow><mo fence="true">⌈</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo fence="true">⌉</mo></mrow></msub><mrow><mo fence="true">(</mo><mi>T</mi><mrow><mo fence="true">(</mo><mi>R</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mo fence="true">⌉</mo></mrow></mrow><annotation encoding="application/x-tex">h = \left\lceil \log_{\left\lceil n/2 \right\rceil} \left( T\left( R \right) \right) \right\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">⌈</span></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28086em;"><span style="top:-2.45586em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">⌈</span></span><span class="mord mathnormal mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">⌉</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.41913999999999996em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">⌉</span></span></span></span></span></span> (每访问一个内部节点都会进行一次I/O操作)</p><p>过滤谓词必须是某个索引的搜索码</p><p>➢ 等值谓词 “ = ”</p><ol><li><p>聚簇索引（元组按搜索码顺序存储在连续的块中）</p><p>搜索码唯一 ，命中一个即结束  <font color="red">h+1</font>次I/O<br>（还有的一次是读取目标元组所在的磁盘块）</p><p>搜索码不唯一 ，会命中多条记录，多条记录存储于连续块 <font color="red">h+b</font>次I/O</p><p>​根据 𝑏 / 𝐵(𝑅) = 𝑇(𝜎<sub>p</sub>(𝑅)) / 𝑇(𝑅)<br>​该记录分布到的块数𝑏 = 𝐵(𝑅) × 𝑇(𝜎<sub>p</sub>(𝑅)) / 𝑇(𝑅)</p></li><li><p>非聚簇索引</p></li></ol><p>搜索码唯一 ，命中一个即结束  <font color="red">h+1</font>次I/O</p><p>搜索码不唯一 ，定位到的记录分布于相对随机的 𝑏′ 个磁盘块， <font color="red">h+ b′ </font>次I/O<br>𝑏′ = 𝐵 (𝜎<sub>𝑝</sub>(𝑅))  = min{ 𝑇(𝜎<sub>p</sub>(𝑅)) ,  B(R) } 这里是代价，故作最坏打算</p><p>➢ 比较谓词 “ ≥v ”</p><ol><li>聚簇索引<br>先定位到v对应的叶子结点，然后从其指向的数据块顺序扫描所有剩余块(b块)<br>h+b = <font color="red">h + B(R) * T(σ<sub>A≥v</sub>(R)) / T(R)</font><br><mark>选择率 =  T(σ<sub>A≥v</sub>(R)) / T(R)</mark></li><li>非聚簇索引<br>先定位到v对应的叶子(h次)，然后向后顺序扫描剩余（γ个）叶子提取所有指向记录的指针，根据获取的指针读取对应数据块（随机I/O T(σ<sub>A≥v</sub>(R))）<br><font color="red">h + γ + T(σ<sub>A≥v</sub>(R))</font><br>γ = T(σ<sub>A≥v</sub>(R)) / n<br>n是B+树因子，每个叶子节点包含 n 个指针。满足条件的指针数为 T(σ<sub>A≥v</sub>(R))</li></ol><p>➢ 比较谓词 “ &lt;v ”</p><ol><li>聚簇索引<br>直接顺序扫描数据块，直到v （无需定位到v对应的叶子，数据块中存储的数据行按照聚簇索引的顺序排列，不使用索引 ）<br><font color="red">B(R) * T(σ<sub>A&lt;v</sub>(R)) / T(R)</font></li><li>非聚簇索引<br>直接顺序扫描索引的叶子提取所有指向记录的指针，直到包含v的叶子（γ个），根据获取的指针读取对应数据块（随机I/O T(σ<sub>A≥v</sub>(R))）<br><font color="red">γ + T(σ<sub>A&lt;v</sub>(R))</font></li></ol><img src="/2024/06/28/49d65152/image-20240619222223120.png" alt="image-20240619222223120" style="zoom: 67%;"><p>索引扫描与仅索引扫描的区别：索引扫描需要额外访问表以取得非索引列，而仅索引扫描则完全依赖索引，不访问表数据。</p><ol><li>索引扫描（Index Scan）:<ul><li>索引扫描需要访问索引来确定哪些行符合查询条件。</li><li>从索引获取到行的指针后，它需要回到数据表中以取得完整的行数据。</li><li>适用于索引覆盖一部分查询条件的情况，需要访问表数据以获取不在索引中的列。</li></ul></li><li>仅索引扫描（Index-Only Scan）:<ul><li>当查询所需的数据完全被索引覆盖时，可以使用仅索引扫描，这时不必访问数据表。</li><li>这种扫描提供更高的性能，因为它避免了对表的访问，仅仅通过索引即可获取所有需要的数据列。</li><li>当查询的列已经全部在索引中时用此方法，减少了对表的I/O访问。</li></ul></li></ol><p><strong>全表扫描VS索引扫描</strong></p><ul><li><strong>全表扫描</strong>：适合小表和需要处理大部分或全部数据的查询。</li><li><strong>聚簇索引扫描</strong>：适合精确匹配和顺序访问大量记录的查询。</li><li><strong>非聚簇索引扫描</strong>：适合精确查询和部分范围查询，但由于数据可能分布在不同块中，随机I/O开销较大。</li></ul><p>等值谓词且搜索码唯一，<strong>索引扫描</strong>好</p><p>等值谓词且搜索码不唯一 and 比较谓词，<strong>聚簇索引扫描</strong>好；全表扫描和非聚簇索引扫描谁好要看选择率，选择率高可能全表扫描相对好，选择率低可能非聚簇索引扫描相对好，</p><h5 id="image-20240619224430882"><a class="markdownIt-Anchor" href="#image-20240619224430882"></a> <img src="/2024/06/28/49d65152/image-20240619224430882.png" alt="image-20240619224430882"></h5><p><img src="/2024/06/28/49d65152/image-20240619224538270.png" alt="image-20240619224538270"></p><h4 id="排序τ"><a class="markdownIt-Anchor" href="#排序τ"></a> 排序τ</h4><h5 id="外归并排序"><a class="markdownIt-Anchor" href="#外归并排序"></a> 外归并排序</h5><p>基于外存，适用于排序无法完全放入内存的大型数据集。</p><p>它通过分阶段的处理，将数据分块排序并逐步归并，最终得到有序的数据</p><p>归并段（ run）</p><ul><li>一个键/值（ Key/Value ）列表</li><li>Key：用于排序的属性列</li><li>Value：元组ID/元组内容</li></ul><p>以2路为例</p><p><img src="/2024/06/28/49d65152/image-20240620004158070.png" alt="image-20240620004158070" style="zoom:50%;">（a是内容，19是行号）</p><p>➢初始分块排序：将大数据集分成适合内存的M块，依次读入M个块(完整的用于排序的K/V列表共占M页)，在内存中进行排序，将排序后的数据块写回到磁盘，形成有序的子文件（runs）</p><p>➢归并排序：从磁盘读取两个有序的子文件合并，生成更大的有序子文件，写回磁盘。上述过程使用缓冲池中的3个帧（2个用于输入、一个输出）<br>重复合并过程，直到所有子文件合并成一个最终的有序输出文件。</p><p>I/O数量：</p><ul><li>趟数（树高）：1 + ⌈log<sub>2</sub>M⌉</li><li>每趟： 2M</li><li>合计： <font color="red">2B(R) × (1 + ⌈log<sub>2</sub>B(R)⌉)</font></li></ul><p><img src="/2024/06/28/49d65152/image-20240620004629306.png" alt="image-20240620004629306" style="zoom:60%;">(磁盘每次只能一页一页读)</p><h4 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接⋈</h4><p>SELECT R.StuID, S.Cno, S.grade FROM Student R, SC S WHERE age = 19 AND R.StuID=S.Sno;</p><h5 id="嵌套循环-nested-loop-join"><a class="markdownIt-Anchor" href="#嵌套循环-nested-loop-join"></a> 嵌套循环 Nested Loop Join</h5><p>➢扫描外表（左表）</p><p>➢ 对于外表的每个符合条件的记录，根据连接条件，扫描内表（右表）来执行连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each tuple i in R:</span><br><span class="line"><span class="keyword">for</span> each tuple j in S:</span><br><span class="line"><span class="keyword">if</span> iθj, 拼接i和j并输出到Join结果</span><br></pre></td></tr></table></figure><p>左表的每一行都想扫一遍右表</p><p>I/O数量：</p><ul><li>外层循环： B(R)</li><li>内层循环： T(R)*B(S)   （左表的每一行都想扫一遍右表）</li><li>合计： <font color="red">B(R)+T(R)*B(S)  </font></li></ul><p>根据不对称产生思考，能否R与S互换，即左右表互换。<mark>结论：小表做外表(左表)</mark> 这样扫一整遍右表的次数少了</p><p><strong>基于块访问方式的改进</strong> <strong>Block</strong> <strong>Nested</strong> <strong>Loop</strong> <strong>Join</strong></p><p>j借助缓冲池，将外表的块读入内存，然后对每个块中的每个元组，与内表的所有元组进行比较。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each 块r in R:</span><br><span class="line"><span class="keyword">for</span> each 块s in S:</span><br><span class="line"><span class="keyword">for</span> each tuple i in R:</span><br><span class="line"><span class="keyword">for</span> each tuple j in S:</span><br><span class="line"><span class="keyword">if</span> iθj, 拼接i和j并输出到Join结果</span><br></pre></td></tr></table></figure><p>尽可能把左表载入缓冲池</p><p>分别保留1帧用于缓冲内表和结果，故可用于缓冲左表的共有(#Buffer - 2)帧</p><p>结果存满一帧（页）即可落盘</p><p>缓冲内表的那一帧主动拼接当时缓冲池所含所有的外表页面</p><p><img src="/2024/06/28/49d65152/image-20240620113405400.png" alt="image-20240620113405400"></p><p>I/O数量：</p><ul><li>外层循环： B(R)</li><li>内层循环： ⌈ B(R) / (#Buffer-2) ⌉ * B(S)</li><li>合计： <font color="red">B(R) +  ⌈ B(R) / (#Buffer-2) ⌉ * B(S)  </font></li><li>如果#Buffer - 2 &gt;= B(R) ，即外表能一次全部放入缓冲池，<font color="red"> B(R) + B(S)  </font></li></ul><h5 id="排序合并-sort-merge-join"><a class="markdownIt-Anchor" href="#排序合并-sort-merge-join"></a> 排序合并 Sort-Merge Join</h5><img src="/2024/06/28/49d65152/image-20240620131849955.png" alt="image-20240620131849955" style="zoom:50%;"><p>➢排序：R,S分别按照连接码排序<br>如果输入关系尚未排序，对两个输入关系分别按连接属性进行排序<br>可以使用外部排序算法，如外归并排序（External Merge Sort），来处理不能完全放入内存的大型数据集。</p><p>➢合并：两表分别维护1个游标按顺序检查匹配<br>分别指向两个已排序关系的第一个元组,比较当前元组对的连接属性值。<br>如果两者匹配，将匹配的元组对加入结果集中，并移动两个游标到下一个元组。<br>如果不匹配，移动具有较小连接属性值的指针到下一个元组，继续比较。<br>直到至少一个关系的所有元组都被处理完。</p><p>I/O数量：</p><ul><li>排序： Sort(B(R)) +  Sort(B(S))</li><li>合并：B(R) + B(S)</li><li>合计： <font color="red">2B(R) × (1 + ⌈log<sub>2</sub>B(R)⌉)  + 2B(S) × (1 + ⌈log<sub>2</sub>B(S)⌉) + B(R) + B(S)  </font></li><li>若表本身已有序则无需排序</li></ul><h5 id="哈希连接-hash-join"><a class="markdownIt-Anchor" href="#哈希连接-hash-join"></a> 哈希连接 Hash Join</h5><p>假设两个关系 R 和 S 分别具有 N 和 M 个块，较小的关系记为R，较大的关系记为S</p><p>当数据量大到无法全部放入内存时，需要使用外部哈希连接。</p><p>➢分桶：扫描R表，在连接码上用哈希函数h将R中的元组映射到不同的桶（构造）<br>扫描S表，用h将S中的元组找到对应的桶，在对应的桶内进行匹配（探查）<br><strong>读取R，用哈希函数h将R分区，将这些分区写回磁盘——2N次I/O</strong><br><strong>读取S，用哈希函数h将S分区，将这些分区写回磁盘——2M次I/O</strong></p><p>➢连接：逐个读取每对分区的块，并在内存中进行哈希连接（直接输出，无需将结果写到磁盘）<br>读取N + M次</p><p>I/O数量：</p><ul><li>分桶：2B(R) + 2S(R)</li><li>连接：B(R) + S(R)</li><li>合计：<font color="red">3B(R) + 3S(R) </font></li><li>若表比较小，能一次放入内存，则可以在内存中直接作哈希连接，<font color="red">B(R) + S(R) </font></li></ul><img src="/2024/06/28/49d65152/image-20240620162754741.png" alt="image-20240620162754741" style="zoom:50%;"><p><strong>嵌套循环连接VS排序合并连接VS哈希连接</strong></p><img src="/2024/06/28/49d65152/image-20240620163059719.png" alt="image-20240620163059719" style="zoom:50%;"><p>范围谓词：只能用<strong>嵌套循环连接</strong></p><p>等值谓词：</p><ul><li>若R或S在连接属性上已有序：<strong>排序合并连接</strong>      <img src="/2024/06/28/49d65152/image-20240620163400524.png" alt="image-20240620163400524" style="zoom:40%;"></li><li>大多数情况：<strong>哈希连接</strong></li><li>DBMS需要进行<font color="red">代价估计</font>（依靠统计信息和代价模型）来决定实际物理操作符的选择</li></ul><h2 id="四-查询优化cbo"><a class="markdownIt-Anchor" href="#四-查询优化cbo"></a> 四、查询优化CBO</h2><p>访问计划：为了执行一条SQL查询语句而将一系列访问方法和连接方法缝合在一起。</p><p>访问路径：假设底层RDBMS支持 j 个连接算法，并且每个表平均有 i 个索引，则每个表有(i+1)个访问方法(还有的那一种是顺序访问)，那么n表连接访问路径总数：<font color="red">n! x (i + 1)<sup>n</sup> x j<sup>n-1</sup></font>   <br>n!：连接顺序<br>(i + 1)<sup>n</sup>：每个表有(i+1)种访问方法<br>j<sup>n-1</sup>：两两连接的方法                       <img src="/2024/06/28/49d65152/image-20240620195439654.png" alt="image-20240620195439654" style="zoom:35%;"></p><p>SQL语言的查询优化是一个<font color="red">NP-Hard</font>问题！</p><p>CBO（基于代价的优化）</p> <img src="/2024/06/28/49d65152/image-20240620205629678.png" alt="image-20240620205629678" style="zoom:50%;"><h4 id="访问计划枚举"><a class="markdownIt-Anchor" href="#访问计划枚举"></a> 访问计划枚举</h4><ul><li>1-复合：<img src="/2024/06/28/49d65152/image-20240620201517751.png" alt="image-20240620201517751" style="zoom:50%;"></li><li>2-复合：<img src="/2024/06/28/49d65152/image-20240620201605509.png" alt="image-20240620201605509" style="zoom:55%;"></li><li>n-复合：(n-1)复合⊕1-复合   自底向上，动态规划（不一定最好）<img src="/2024/06/28/49d65152/image-20240620204034570.png" alt="image-20240620204034570" style="zoom:50%;"></li></ul> <img src="/2024/06/28/49d65152/image-20240620204837844.png" alt="image-20240620204837844" style="zoom:50%;"><p>连接顺序剪枝：通过排除不可能的或低效的组合以提高优化器效率的方法，例如将过滤后行数少的表作为驱动表（首表）进行连接</p><h4 id="代价估算"><a class="markdownIt-Anchor" href="#代价估算"></a> 代价估算</h4><h5 id="开销模型"><a class="markdownIt-Anchor" href="#开销模型"></a> 开销模型</h5><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>cost</mtext><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mtext>cost</mtext><mi>i</mi></msub><mo>=</mo><msubsup><mtext>cost</mtext><mi>i</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msubsup><mo>+</mo><msubsup><mtext>cost</mtext><mi>i</mi><mrow><mi>C</mi><mi>P</mi><mi>U</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\text{cost} = \sum_i \text{cost}_i = \text{cost}_i^{I/O} + \text{cost}_i^{CPU}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">cost</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord text"><span class="mord">cost</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.321664em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord text"><span class="mord">cost</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord text"><span class="mord">cost</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>是DBMS用于从众多访问路径中选择执行计划的基础，用于计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>P</mi><mn>1</mn><mo>∗</mo></msubsup><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>t</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>δ</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>arg</mi><mo>⁡</mo><msub><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mi>s</mi><mo>∈</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></msub><mtext>cost</mtext><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_1^* (\{t\}) = \delta^* (t) = \arg \min_{s \in \delta(t)} \text{cost}(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.03785em;">δ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">cost</span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></p><p>估算查询执行计划的代价，包括I/O、CPU、内存、网络等资源的消耗，这些开销与数据量密切相关</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>cost</mtext><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><msub><mtext>cost</mtext><mi>i</mi></msub><mo>=</mo><msubsup><mtext>cost</mtext><mi>i</mi><mrow><mi>I</mi><mi mathvariant="normal">/</mi><mi>O</mi></mrow></msubsup><mo>+</mo><msubsup><mtext>cost</mtext><mi>i</mi><mrow><mi>C</mi><mi>P</mi><mi>U</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">\text{cost} = \sum_i \text{cost}_i = \text{cost}_i^{I/O} + \text{cost}_i^{CPU}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">cost</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord text"><span class="mord">cost</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.321664em;vertical-align:-0.27686399999999994em;"></span><span class="mord"><span class="mord text"><span class="mord">cost</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span><span class="mord mtight">/</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0999949999999998em;vertical-align:-0.253684em;"></span><span class="mord"><span class="mord text"><span class="mord">cost</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8463109999999999em;"><span style="top:-2.4463160000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0679800000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.253684em;"><span></span></span></span></span></span></span></span></span></span></p><p>统一标准量：为了选择唯一的执行计划，需要将右侧归一为标准量，可以采用相对比例或绝对大小参考值。</p><p>需要用到基数估算和选择率估计</p><p>基数估算：使用统计信息估算 选择、连接等查询操作 返回的元组数量<br>基数(cardinality)是指查询结果的元组数</p><p>选择率估计：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>T</mi><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>p</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">S_p(R) = \frac{T(σ_p(R))}{T(R)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.55232em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03232em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.50732em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mclose mtight">)</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><h5 id="统计信息"><a class="markdownIt-Anchor" href="#统计信息"></a> 统计信息</h5><p>统计信息是关于<font color="red">数据分布和表结构的元数据</font>，帮助查询优化器估算查询操作的代价。</p><p>DBMS会自动收集所有索引列以及最多k个非索引列的统计信息，在数据字典中存储</p><p>通常包括：</p><ul><li><p>表的统计信息：</p><ul><li>T(R)：总行数，表中记录的总数</li></ul></li><li><p>列的统计信息：</p><ul><li><p>Card(R,A)：列 A 中不同值的数目</p></li><li><p>Null(R,A)：列 A 中NULL 值的数目</p></li><li><p>Hist(R,A)：直方图(histogram)，列 A 值的分布情况。 更细粒度</p></li></ul></li></ul><p>选择率估计：</p><p>均匀分布？属性独立？</p><p>need 总行数、基数、直方图</p><table><thead><tr><th style="text-align:center">查询</th><th style="text-align:center">情况</th><th style="text-align:center">Card(R,A)</th><th style="text-align:center">S<sub>p</sub>(R)</th></tr></thead><tbody><tr><td style="text-align:center"><code>SELECT * FROM Student WHERE StuID = '95002';</code></td><td style="text-align:center">唯一值且不同</td><td style="text-align:center">T(R)</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">S_p(R) = \frac{1}{T(R)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td></tr><tr><td style="text-align:center"><code>SELECT * FROM Student WHERE Ssex = '男';</code></td><td style="text-align:center">均匀分布</td><td style="text-align:center">2</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>p</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mtext>Card</mtext><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">S_p(R) = \frac{1}{\text{Card}(R, A)} = \frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Card</span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">A</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td></tr><tr><td style="text-align:center"><code>SELECT * FROM Student WHERE Sage &lt; 18;</code></td><td style="text-align:center">非均匀分布</td><td style="text-align:center">4</td><td style="text-align:center">不能简单用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mtext>Card</mtext><mo stretchy="false">(</mo><mi>R</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\text{Card}(R, A)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">Card</span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">A</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>表示，要用直方图Hist(R,A)算范围占比</td></tr><tr><td style="text-align:center"><code>SELECT * FROM Student WHERE Sage &lt; 17 AND Ssex=‘男’</code></td><td style="text-align:center">属性独立</td><td style="text-align:center"></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mrow><mi>p</mi><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>S</mi><mrow><mi>p</mi><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S_{p1}(R) * S_{p2}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span></td></tr><tr><td style="text-align:center"><code>SELECT * FROM Student WHERE Ssex=‘男’ AND Department=‘CS’;</code></td><td style="text-align:center">属性不独立（列之间有相关性）</td><td style="text-align:center"></td><td style="text-align:center">不能直接相乘</td></tr></tbody></table><p>有了选择率可以计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>P</mi><mn>1</mn><mo>∗</mo></msubsup><mo stretchy="false">(</mo><mo stretchy="false">{</mo><mi>t</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>δ</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>arg</mi><mo>⁡</mo><msub><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mi>s</mi><mo>∈</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></msub><mtext>cost</mtext><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_1^* (\{t\}) = \delta^* (t) = \arg \min_{s \in \delta(t)} \text{cost}(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.03785em;">δ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">cost</span></span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></p><p>统计信息的维护：</p><ul><li>定期或较低负载或重大改变更新</li><li>主动收集 ANALYZE命令</li><li>基数估计：蓄水池采样(随机采样)→HyperLogLog(概率算法)</li><li>直方图估计：蓄水池采样(随机采样)→<ul><li>等宽直方图：区间宽度相同</li><li>等深直方图：区间深度相同，每个区间数据出现的频率大致相等</li></ul></li></ul><p>统计信息的局限性：只能支持原始表 ，无法支持查询过程中的中间结果，可靠性会级联递减</p><p>RBO-CBO案例分析</p><img src="/2024/06/28/49d65152/image-20240620235609731.png" alt="image-20240620235609731" style="zoom:50%;"><h2 id="五-执行引擎"><a class="markdownIt-Anchor" href="#五-执行引擎"></a> 五、执行引擎</h2><h5 id="cbo输出"><a class="markdownIt-Anchor" href="#cbo输出"></a> CBO输出</h5><p>最优的物理计划</p><p>执行计划QEP (Query Execution Plan)</p><h5 id="执行模型"><a class="markdownIt-Anchor" href="#执行模型"></a> 执行模型</h5><p>给定QEP， DBMS执行的流程：QEP中每个物理操作符对应一段具体代码实现</p><ul><li>物化模型：每一步物理操作符的中间结果物化（甚至落盘） 后，用于下一步输入<ul><li>每个操作符一次性读入所有输入（元组）</li><li>一次性输出所有（元组）</li><li>等每一步的结果完全弄好才能进行下一步<img src="/2024/06/28/49d65152/image-20240621010135831.png" alt="image-20240621010135831" style="zoom:43%;"></li></ul></li><li>火山模型 ：物理操作符的结果元组直接发送给下一个操作符使用（每个操作符需要实现一个Next()方法），中间不需物化<ul><li>每个操作符看成是迭代器，父节点-&gt;外层迭代   子节点-&gt;内层迭代</li><li>操作符（迭代层）间传递的是单个元组（投影）</li><li>有一个产生就可以开始迭代处理了（像火山一样往上冒）</li><li>优点是减少了存储开销和I/O操作，提高了执行效率。</li><li><img src="/2024/06/28/49d65152/image-20240621011515676.png" alt="image-20240621011515676"></li></ul></li><li>向量化模型：类似火山模型，但传递的不是单个元组，而是一批元组<ul><li>一个向量内含多组内容</li><li>以更好的利用现代CPU的SIMD指令 （单指令多数据流）</li><li><img src="/2024/06/28/49d65152/image-20240621011913713.png" alt="image-20240621011913713"></li></ul></li></ul><p><img src="/2024/06/28/49d65152/image-20240621012248791.png" alt="image-20240621012248791"></p><p><strong>《数据库原理》课程笔记：</strong></p><ol><li><a href="/2024/06/28/9bd3300d.html" title="第一章 数据库系统概述和关系模型">第一章 数据库系统概述和关系模型</a></li><li><a href="/2024/06/28/257e255e.html" title="第七章 事务处理、并发和恢复">第七章 事务处理、并发和恢复</a></li><li><a href="/2024/06/28/885ffcc2.html" title="第二章 关系模式规范化">第二章 关系模式规范化</a></li><li><a href="/2024/06/28/d9c30aa5.html" title="第五章 存储和索引技术">第五章 存储和索引技术</a></li><li><a href="/2024/06/28/49d65152.html" title="第六章 查询处理和优化">第六章 查询处理和优化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 存储和索引技术</title>
      <link href="/2024/06/28/d9c30aa5.html"/>
      <url>/2024/06/28/d9c30aa5.html</url>
      
        <content type="html"><![CDATA[<p>主要内容：数据库存储引擎和索引的重要概念，包括行、列存储模型；缓冲池的设计和作用、哈希索引和树型索引技术。</p><ol><li>基本要求</li></ol><p>a）熟悉数据库存储引擎</p><p>b）熟悉关数据库索引机制</p><p>c）掌握存储层的各种索引技术</p><ol start="2"><li>重点、难点</li></ol><p><strong>重点:</strong> 存储层的索引技术</p><h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h2><p>索引项：搜索码+指针</p><p>索引文件：一组索引项构成的表格，远小于原始数据文件</p><p>索引类型：</p><ul><li>哈希索引：搜索码按照哈希函数放桶 看ppt<ul><li>静态哈希表：桶数固定</li><li>动态哈希表：<ul><li>可扩展哈希表</li><li>线性哈希表</li></ul></li></ul></li><li>顺序索引：搜索码按顺序组织<ul><li>聚簇索引（主索引）</li><li>非聚簇索引（辅助索引）</li><li>稠密索引：每个<font color="blue">搜索码值</font>对应一个索引项，有多少<font color="blue">不同值</font>就有多少索引项</li><li>稀疏索引：只为某些搜索码值建立索引项，只在记录按搜索码排序时可用（即只有主索引才可稀疏）<ul><li>定位一条搜索码值为k的记录：找到搜索码值为&lt;=k的最大值的索引项，从该索引项指向的记录开始在文件中顺序查找   <img src="/2024/06/28/d9c30aa5/image-20240626204708676.png" alt="image-20240626204708676"></li><li>空间开销和维护成本更小，但是搜索效率略低</li></ul></li></ul></li></ul><p>多级索引：</p><ul><li><p>如果索引文件过大，超过内存容量 ，可以将原始顺序索引文件落盘，在其基础上建立一个<font color="blue">稀疏索引</font>，形成内-外索引两级结构</p></li><li><ul><li>外索引:  在基本索引上建立的一个稀疏索引</li><li>内索引:  基本索引文件</li></ul><p><img src="/2024/06/28/d9c30aa5/image-20240626205451830.png" alt="image-20240626205451830"></p></li></ul><p><img src="/2024/06/28/d9c30aa5/image-20240626205632739.png" alt="image-20240626205632739"></p><h3 id="b树索引"><a class="markdownIt-Anchor" href="#b树索引"></a> B+树索引</h3><p>平衡：叶节点深度一样</p><p>n阶B+树有 n 个指针，n-1 个键</p><p>节点结构：<img src="/2024/06/28/d9c30aa5/image-20240626210947611.png" alt="image-20240626210947611"></p><ul><li><p>中间节点：<img src="/2024/06/28/d9c30aa5/image-20240626211555787.png" alt="image-20240626211555787" style="zoom:20%;"></p></li><li><p>叶子结点：<img src="/2024/06/28/d9c30aa5/image-20240626211701780.png" alt="image-20240626211701780" style="zoom:33%;"></p><p><img src="/2024/06/28/d9c30aa5/image-20240626213112357.png" alt="image-20240626213112357"></p></li></ul><p>根节点只少有2个子节点，当根节点为叶节点时，其子节点为0至n-1</p><p>至少占一半：</p><p>每个中间节点有<font color="red"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⌈</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo fence="true">⌉</mo></mrow><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\left\lceil \frac{n}{2} \right\rceil \sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌈</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌉</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></font>个子节点</p><p>每个叶子节点有<font color="red"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⌈</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo fence="true">⌉</mo></mrow><mo>∼</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\left\lceil \frac{n-1}{2} \right\rceil \sim n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌈</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌉</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></font>个值</p><p>树深 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mrow><mo fence="true">⌈</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mrow><mo fence="true">⌈</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo fence="true">⌉</mo></mrow></msub><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo fence="true">⌉</mo></mrow></mstyle></mrow><annotation encoding="application/x-tex">\textcolor{red}{\left\lceil \log_{\left\lceil \frac{n}{2} \right\rceil} (k) \right\rceil}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.8052em;vertical-align:-0.6552em;"></span><span class="minner" style="color:red;"><span class="mopen delimcenter" style="color:red;top:0em;"><span class="delimsizing size2" style="color:red;"><span style="color:red;">⌈</span></span></span><span class="mop" style="color:red;"><span class="mop" style="color:red;"><span style="color:red;">l</span><span style="color:red;">o</span><span style="margin-right:0.01389em;color:red;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.6473000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;"><span class="minner mtight" style="color:red;"><span class="mopen sizing reset-size3 size6 mtight delimcenter" style="color:red;top:0.07500000000000001em;"><span class="mtight" style="color:red;">⌈</span></span><span class="mord mtight" style="color:red;"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight" style="color:red;"><span class="mord mtight" style="color:red;"><span class="mord mtight" style="color:red;">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="color:red;border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight" style="color:red;"><span class="mord mtight" style="color:red;"><span class="mord mathnormal mtight" style="color:red;">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose sizing reset-size3 size6 mtight delimcenter" style="color:red;top:0.07500000000000001em;"><span class="mtight" style="color:red;">⌉</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6552em;"><span></span></span></span></span></span></span><span class="mopen" style="color:red;">(</span><span class="mord mathnormal" style="margin-right:0.03148em;color:red;">k</span><span class="mclose" style="color:red;">)</span><span class="mclose delimcenter" style="color:red;top:0em;"><span class="delimsizing size2" style="color:red;"><span style="color:red;">⌉</span></span></span></span></span></span></span>      ( k 是搜索码总量)</p><p>每次节点访问都会IO</p><p>各类算法 看书和ppt</p><p><strong>《数据库原理》课程笔记：</strong></p><ol><li><a href="/2024/06/28/9bd3300d.html" title="第一章 数据库系统概述和关系模型">第一章 数据库系统概述和关系模型</a></li><li><a href="/2024/06/28/257e255e.html" title="第七章 事务处理、并发和恢复">第七章 事务处理、并发和恢复</a></li><li><a href="/2024/06/28/885ffcc2.html" title="第二章 关系模式规范化">第二章 关系模式规范化</a></li><li><a href="/2024/06/28/d9c30aa5.html" title="第五章 存储和索引技术">第五章 存储和索引技术</a></li><li><a href="/2024/06/28/49d65152.html" title="第六章 查询处理和优化">第六章 查询处理和优化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 事务处理、并发和恢复</title>
      <link href="/2024/06/28/257e255e.html"/>
      <url>/2024/06/28/257e255e.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-事务处理-并发和恢复"><a class="markdownIt-Anchor" href="#第七章-事务处理-并发和恢复"></a> 第七章 事务处理、并发和恢复</h1><p>主要内容：数据库事务的概念，事务的ACID特性，基于锁的并发协议，死锁处理，多版本机制，快照隔离</p><p>1） 基本要求</p><ol><li>了解事务的基本概念</li><li>熟悉事务的ACID特性</li><li>了解并发控制和多版本机制的基本原理</li></ol><p>2） 重点、难点</p><p><strong>重点：</strong> 事务的ACID特性</p><p><strong>难点：</strong> 基于WAL的恢复机制</p><p>主要内容：数据库事务隔离性要求的具体实现-并发控制</p><p>1） 基本要求</p><ol><li>了解并发控制和多版本机制的基本原理</li></ol><p>2） 重点、难点</p><p><strong>重点：</strong> 并发控制的机制</p><p><strong>难点：</strong> 2阶段锁</p><p>主要内容：数据库事务原子性和持久性的要求和具体实现-日志和恢复</p><p>1） 基本要求</p><ol><li>了解并日志和恢复的基本原理，及对原子性、持久性的支撑</li></ol><p>2） 重点、难点</p><p><strong>重点：</strong> WAL、redo、undo</p><p><strong>难点：</strong> 基于日志的恢复</p><h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2><h4 id="事务的定义"><a class="markdownIt-Anchor" href="#事务的定义"></a> 事务的定义：</h4><ul><li>访问并可能更新各种数据项的一个程序执行单元</li><li>事务是多个数据库操作组合成的一个不可分割的、同时成功或失败的工作单元</li><li><img src="/2024/06/28/257e255e/image-20240621125712324.png" alt="image-20240621125712324"></li><li>显示： COMMIT/ROLLBACK<br>隐式： 由DBMS自动划分</li><li>E.g.  账户A向账户B转账50元 （A=A-50, B=B+50）<br>用户A向12306订G01次车票一张 (A=A+1, G01=G01-1)   <img src="/2024/06/28/257e255e/image-20240621125910235.png" alt="image-20240621125910235" style="zoom:60%;"></li><li>事务具有四个特性（ACID）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）</li></ul><h4 id="事务的要求"><a class="markdownIt-Anchor" href="#事务的要求"></a> 事务的要求：</h4><p>事务保持正确性的评判准则</p><p>原子性（atomicity）：<font color="red">不可分割</font>，一个事务包含的所有操作“要么全都执行，要么全都不执行”</p><p>一致性（consistency）：<font color="red">正确一致</font>，事务的执行不改变数据库实例的一致性 ,即事务执行前数据库满足一致性，执行后也满足一致性</p><p>隔离性（isolation）：<font color="red">互不干扰</font>，事务之间相互隔离，即对并发执行的其他事务无感知 (多个事务在并发执行的过程中所得到的结果，和串行执行得到的结果是一致)</p><p>持久性（durability）：<font color="red">永久保持</font>，一旦某个事务执行完成，其对数据的更改将持久化反应到数据库实例上</p><h5 id="原子性atomicity"><a class="markdownIt-Anchor" href="#原子性atomicity"></a> 原子性（Atomicity）</h5><p><font color="red">不可分割</font>，一个事务包含的所有操作“要么全都执行，要么全都不执行”</p><img src="/2024/06/28/257e255e/image-20240621130910342.png" alt="image-20240621130910342" style="zoom:50%;"><p>事务状态：</p><ol><li>活跃(active)： 事务开始执行时的初始状态</li><li>部分提交(partially committed)： 最后一条语句被执行后，提交之前</li><li>失效(failed) ： 发现该事务不能再继续正常执行了</li><li>中止(aborted) ： 事务已经回滚，数据库实例已恢复到事务开始前的状态，中止之后可选择 重启事务 和 杀死事务  操作</li><li>提交(committed) ： 事务成功完成之后</li></ol><p>原子性只允许事务最终处于 提交态(全都执行) 或 中止态(全都不执行)</p><p>保障原子性的机制 ：</p><ul><li>日志<ul><li>DBMS用日志记录所有的操作</li><li>事务一旦中止，可以回溯日志以回滚操作</li></ul></li><li>影子分页技术<ul><li>对页面拷贝</li><li>事务优先在拷贝页面上执行</li><li>仅当执行提交（commit） 后，才持久化可见</li></ul></li></ul><h5 id="一致性consistency"><a class="markdownIt-Anchor" href="#一致性consistency"></a> 一致性（consistency）</h5><p><font color="red">正确一致</font>，事务的执行不改变数据库实例的一致性，即事务执行前数据库满足一致性，执行后也满足一致性</p><p>显式的完整性约束</p><p>隐式的完整性约束：E.g. SUM(R.收入)-SUM(R.支出)=SUM(R.利润)</p><p>事务执行前：数据库实例应满足一致性要求   E.g. 已出售票量+剩余票量=总票量</p><p>事务执行中：允许暂时的不一致</p><p>事务执行完（无论成功与否）：数据库实例应满足一致性要求  E.g. 已出售票量+剩余票量=总票量</p><p>如果不一致，说明事务执行有问题</p><p>保证事务一致性应是<font color="red">上层应用</font>的职责，即语句编写者</p><h5 id="隔离性isolation"><a class="markdownIt-Anchor" href="#隔离性isolation"></a> 隔离性（isolation）</h5><p><font color="red">互不干扰</font>，事务之间相互隔离，即对并发执行的其他事务无感知 (多个事务在并发执行的过程中所得到的结果，和串行执行得到的结果是一致)</p><p>事务的穿插执行可能破坏一致性 / 并发执行产生冲突</p><p><font color="red">并发控制</font>是实现事务隔离性的手段</p><p>调度：多个并发事务的操作穿插执行的顺序</p><p>串行化调度：串行执行 如果调度S没有对其中各事务的操作进行穿插执行（即调度S严格将事务依次执行），那么称调度S为串行的</p><p>可串行化调度：如果一个调度S等价于另一个串行化的调度S’，那么这个调度S称为可串行化的</p><p>调度等价：</p><ul><li>冲突可串行化<ul><li>冲突：分属于两个事务，访问同一数据对象，至少一个为写<ul><li><strong>读-写冲突</strong>（不可重复读）：事务1读取数据后，事务2执行更新（增删改）操作，使事务1无法再现前一次读取结果</li><li><strong>写-读冲突</strong>（读“赃”数据）：事务1修改某一数据，并将其写回磁盘，事务2读取同一数据后，事务1由于某种原因被撤消。这时事务1已修改过的数据恢复原值，事务2读到的数据就与数据库中的数据不一致，是不正确的数据，又称为“脏”数据</li><li><strong>写-写冲突</strong> （丢失修改）：事务1与事务2从数据库中读入同一数据并修改，事务2的提交结果破坏了事务1提交的结果，导致事务1的修改被丢失</li></ul></li><li>冲突等价：交换无冲突的操作的次序</li><li>冲突可串行化：当调度S 与另一串行调度是冲突等价的，则称调度S是冲突可串行化的</li></ul></li><li>视图可串行化<ul><li><img src="/2024/06/28/257e255e/image-20240622200731576.png" alt="image-20240622200731576"></li><li><img src="/2024/06/28/257e255e/image-20240622200747568.png" alt="image-20240622200747568"></li></ul></li><li><img src="/2024/06/28/257e255e/image-20240622200800488.png" alt="image-20240622200800488"></li></ul><p><strong>利用优先图进行冲突可串行化测试</strong></p><p>无环 链式  &lt;=&gt; 冲突可串行化</p><p><img src="/2024/06/28/257e255e/image-20240622201122622.png" alt="image-20240622201122622">  <img src="/2024/06/28/257e255e/image-20240622201148773.png" alt="image-20240622201148773"></p><p><strong>隔离级别</strong>（由高到低，一步步放宽）</p><p>有些应用场景可允许不可串行调度的执行</p><ul><li>可串行化<ul><li>可能出现的问题：无</li></ul></li><li>可重复读：只允许读取已提交的数据（不会出现脏读），不允许一个事务两次读取之间其他事务对其更新（不会出现不可重复读 因此 可重复读）<ul><li>可能出现的问题：丢失修改</li></ul></li><li>已提交读：只允许读取已提交的数据（不会出现脏读），但并不要求可重复读（读间可更新）（会出现不可重复读）<ul><li>可能出现的问题：丢失修改 + 不可重复读</li></ul></li><li>未提交读：允许读取未提交数据<ul><li>可能出现的问题：丢失修改 + 不可重复读 + 脏读</li></ul></li></ul><h5 id="持久性durability"><a class="markdownIt-Anchor" href="#持久性durability"></a> 持久性（durability）</h5><p><font color="red">永久保持</font>，一旦某个事务执行完成，其对数据的更改将持久化反应到数据库实例上</p><p>保障持久性的机制</p><ul><li><p>日志</p></li><li><p>影子分页技术</p></li></ul><img src="/2024/06/28/257e255e/image-20240622203558525.png" alt="image-20240622203558525" style="zoom:150%;"><h2 id="两阶段锁协议2pl"><a class="markdownIt-Anchor" href="#两阶段锁协议2pl"></a> 两阶段锁协议（2PL）</h2><p>互斥锁（X）：既可读又可写</p><p>共享锁（S）：只可读不可写</p><p>每个事务根据自己的操作类型申请数据项上对应的锁</p><p>锁管理器：管理事务对于锁的申请和授予</p><p>事务仅当被授予数据项的对应锁，才可访问该数据项</p><p><img src="/2024/06/28/257e255e/image-20240624004231564.png" alt="image-20240624004231564"></p><p>朴素的加锁：不能确保串行化</p><p>延迟解锁：死锁、饿死</p><p>两阶段封锁协议（2PL）：</p><p>2-PL是冲突可串行化的充分非必要条件， （一个调度）所有事务均满足2-PL协议=&gt;冲突可串行化 ，存在一些冲突可串行化的调度并不能通过2-PL协议获得</p><p>2-PL不能保证没有死锁</p><p><strong>2-PL协议（允许锁转换）：</strong></p><ul><li>阶段1： 增长阶段<br>事务获取锁，但不能释放锁<br>事务可从S锁升级至X锁</li><li>阶段2： 缩减阶段  （要等锁增长完才能进入阶段2）<br>事务可以释放锁，但不能获得新锁<br>事务可从X锁降级至S锁</li></ul><p><img src="/2024/06/28/257e255e/image-20240624010713199.png" alt="image-20240624010713199"></p><p><img src="/2024/06/28/257e255e/image-20240624011123759.png" alt="image-20240624011123759"></p><p>给数据表加锁是说锁定整张表</p><h2 id="日志和恢复"><a class="markdownIt-Anchor" href="#日志和恢复"></a> 日志和恢复</h2><h3 id="崩溃恢复策略设计"><a class="markdownIt-Anchor" href="#崩溃恢复策略设计"></a> 崩溃恢复策略设计</h3><p><strong>持久性：</strong> 如果在崩溃时刻一个已提交的事务对数据库的修改没有从缓冲区写回磁盘，那么事务的持久性受到了影响，需要重做这些事务</p><ul><li>Force（强制）：事务每次修改都强制写入磁盘，保证持久性（但是消耗系统资源）</li><li><strong>No-Force（非强制）：</strong> 事务每次修改不强制写入磁盘，但是会影响持久性。因此在事务提交之前，将该事务所有对数据库的影响以日志的形式写回磁盘 崩溃会重做日志</li></ul><p><strong>原子性：</strong> 如果在崩溃时刻一个未结束的事务对数据库的修改有一部分已经从缓冲区写回磁盘，那么事务的原子性受到了影响，需要回滚这些事务</p><ul><li>NO-STEAL（非窃取）：只要事务还没提交，它的一切修改都不写入磁盘，保证原子性（但是占用大量缓冲区空间）</li><li><strong>STEAL（窃取）：</strong> 未提交事务的修改也可以写入磁盘，影响原子性。因此在事务将修改写入磁盘之前，先向磁盘写入可以撤销修改的回滚日志</li></ul><p>预写日志（WAL）：每次更改数据之前，先在日志中添加对应的记录  ；即日志在数据页之前刷新</p><p>当数据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 修改数据项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> （<font color="red">Write(X)</font>）时产生 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>T</mi><mo separator="true">,</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>v</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo separator="true">,</mo><msub><mi>v</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt; T, X, v_{new} , v_{old}&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></p><p><strong>重做日志：</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>T</mi><mo separator="true">,</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>v</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt; T, X, v_{new} &gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>  记录事务对数据库的所有影响，保存<font color="red">更新以后</font>的值，恢复子系统<font color="red">从前往后</font>扫描重做日志</p><p><strong>回滚日志：</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>T</mi><mo separator="true">,</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>v</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt; T, X, v_{old} &gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>  记录撤销事务所需的内容，保存<font color="red">修改以前</font>的值，恢复子系统<font color="red">从后往前</font>扫描重做日志</p><p><strong>没有提交和中止的事务要undo回滚 （找没有commit的）</strong></p><p><strong>有提交或中止的事务要redo重做（找已经commit的）</strong></p><p><strong>检查点：</strong>    <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mtext> </mtext><mi>T</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;checkpoint\ T&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></p><p><img src="/2024/06/28/257e255e/13a642c2f7b8cf3ae593e6a4297bece9_720.jpg" alt="img"></p><p><strong>《数据库原理》课程笔记：</strong></p><ol><li><a href="/2024/06/28/9bd3300d.html" title="第一章 数据库系统概述和关系模型">第一章 数据库系统概述和关系模型</a></li><li><a href="/2024/06/28/257e255e.html" title="第七章 事务处理、并发和恢复">第七章 事务处理、并发和恢复</a></li><li><a href="/2024/06/28/885ffcc2.html" title="第二章 关系模式规范化">第二章 关系模式规范化</a></li><li><a href="/2024/06/28/d9c30aa5.html" title="第五章 存储和索引技术">第五章 存储和索引技术</a></li><li><a href="/2024/06/28/49d65152.html" title="第六章 查询处理和优化">第六章 查询处理和优化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 关系模式规范化</title>
      <link href="/2024/06/28/885ffcc2.html"/>
      <url>/2024/06/28/885ffcc2.html</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-关系模式规范化"><a class="markdownIt-Anchor" href="#第二章-关系模式规范化"></a> 第二章 关系模式规范化</h1><p>主要内容：数据库的逻辑结构设计；数据库设计中的关系模式规范化理论</p><ol><li>基本要求</li></ol><p>a）掌握关系数据库的重要理论基础，关系数据理论</p><ol start="2"><li>重点、难点</li></ol><p><strong>重点：</strong> 关系模式规范化</p><p>​1NF,2NF,3NF,BCNF</p><h3 id="一-关系的定义和关系模型三要素"><a class="markdownIt-Anchor" href="#一-关系的定义和关系模型三要素"></a> 一、关系的定义和关系模型三要素</h3><h4 id="1-关系的定义"><a class="markdownIt-Anchor" href="#1-关系的定义"></a> 1. 关系的定义</h4><ul><li><strong>域 (Domain)</strong>：一组具有相同数据类型的值的集合，如整数、字符串等。</li><li><strong>笛卡尔积 (Cartesian Product)</strong>：给定一组域D1, D2, …, Dn，笛卡尔积为 D1 × D2 × … × Dn。</li><li><strong>元组 (Tuple)</strong>：笛卡尔积中的一个元素，如 (d1, d2, …, dn)。</li><li><strong>di</strong>：元组(d1, d2, …, dn)的第i个分量</li><li><strong>关系(Relation)</strong>：笛卡尔积的一个子集。</li><li><strong>n元关系</strong></li><li><img src="/2024/06/28/885ffcc2/image-20240627000703534.png" alt="image-20240627000703534" style="zoom:33%;"></li><li></li></ul><p><img src="/2024/06/28/885ffcc2/image-20240627000703534.png" alt></p><ul><li><img src="/2024/06/28/885ffcc2/image-20240627000724098.png" alt="image-20240627000724098" style="zoom:33%;"></li><li><strong>关系模式：</strong> R(U)</li></ul><h4 id="2-关系模型三要素"><a class="markdownIt-Anchor" href="#2-关系模型三要素"></a> 2. 关系模型三要素</h4><ul><li><strong>关系数据结构</strong>：二维表格结构，用来表示实体和联系。</li><li><strong>关系操作</strong>：包括查询（并、交、差、笛卡尔积、选择、投影、连接、除）、插入、删除和修改。</li><li><strong>关系完整性约束</strong>：<ul><li>实体完整性：主键不可空和重复</li><li>参照完整性</li><li>用户定义完整性。</li></ul></li></ul><p><strong>《数据库原理》课程笔记：</strong></p><ol><li><a href="/2024/06/28/9bd3300d.html" title="第一章 数据库系统概述和关系模型">第一章 数据库系统概述和关系模型</a></li><li><a href="/2024/06/28/257e255e.html" title="第七章 事务处理、并发和恢复">第七章 事务处理、并发和恢复</a></li><li><a href="/2024/06/28/885ffcc2.html" title="第二章 关系模式规范化">第二章 关系模式规范化</a></li><li><a href="/2024/06/28/d9c30aa5.html" title="第五章 存储和索引技术">第五章 存储和索引技术</a></li><li><a href="/2024/06/28/49d65152.html" title="第六章 查询处理和优化">第六章 查询处理和优化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 数据库系统概述和关系模型</title>
      <link href="/2024/06/28/9bd3300d.html"/>
      <url>/2024/06/28/9bd3300d.html</url>
      
        <content type="html"><![CDATA[<h2 id="重点和难点"><a class="markdownIt-Anchor" href="#重点和难点"></a> 重点和难点</h2><ol><li><strong>重点</strong>：数据库和关系模型的基本概念，ER模型、关系数据理论</li><li><strong>难点</strong>：数据库系统的结构</li></ol><h2 id="一-数据库基本概念"><a class="markdownIt-Anchor" href="#一-数据库基本概念"></a> 一、数据库基本概念</h2><ol><li><p><strong>数据库 (Database, DB)</strong></p><ul><li>长期存储在计算机内、有组织、可共享的数据集合。</li><li>例子：学生信息数据库，包含学号、姓名、性别等信息。</li></ul></li><li><p><strong>数据库管理系统 (Database Management System, DBMS)</strong></p><ul><li>管理数据库的软件，提供数据定义、数据操纵、数据控制等功能。</li><li>例子：MySQL, PostgreSQL, Oracle。</li><li>主要功能：<ul><li>数据定义功能：由数据定义语言 (Data Definition Language, DDL) 定义数据库中的数据对象。</li><li>数据组织、存储和管理：分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。</li><li>数据操纵功能：由数据操纵语言 (Data Manipulation Language, DML) 实现对数据库的查询、插入、删除和修改。</li><li>数据控制功能：由数据控制语言 (Data Control Language, DCL) 实现数据保护和事务管理等功能。</li></ul></li><li><img src="/2024/06/28/9bd3300d/image-20240615192439346.png" alt="image-20240615192439346" style="zoom:50%;"></li></ul></li><li><p><strong>数据库系统 (Database System, DBS)</strong></p><ul><li><p>包含数据库、DBMS、应用程序和数据库管理员 (DBA)。</p><img src="/2024/06/28/9bd3300d/image-20240615184414435.png" alt="image-20240615184414435" style="zoom:50%;"></li></ul></li></ol><h2 id="二-数据模型"><a class="markdownIt-Anchor" href="#二-数据模型"></a> 二、数据模型</h2><ol><li><p><strong>数据模型</strong>：现实世界数据特征的抽象。主要包括三个要素：</p><ul><li><strong>数据结构</strong>：（静态）描述数据库组成对象及其联系。</li><li><strong>数据操纵</strong>：（动态）描述对数据库中各种对象的操作，如查询、插入、删除、修改。</li><li><strong>数据完整性约束</strong>：（规则）描述数据的约束规则，确保数据的正确性和一致性。</li></ul></li><li><p><strong>分类</strong>（根据模型应用的不同目的）：</p><ul><li><p><strong>概念模型</strong>：按用户的观点对数据和信息建模，主要用于数据库设计。</p><p>​联系：一对一联系(1:1)    一对多联系(1:N)     多对多联系(M:N)</p><p>​<strong><mark>E-R图</mark></strong>：<strong>实体</strong>用矩形表示，<strong>属性</strong>用椭圆形表示，<strong>联系</strong>用菱形表示，连接线表示实体与属性、实体与联系之间的关系</p><img src="/2024/06/28/9bd3300d/image-20240615172620650.png" alt="image-20240615172620650" style="zoom:50%;"><img src="/2024/06/28/9bd3300d/image-20240615172559055.png" alt="image-20240615172559055" style="zoom:50%;"></li><li><p><strong>逻辑模型</strong>： 它按计算机系统的观点对数据建模，用于DBMS实现。</p><ul><li><p><strong>层次模型</strong>：以树型结构表示数据。只能一对多 不能多对多</p></li><li><p><strong>网状模型</strong>：以网型结构表示数据。</p></li><li><p><strong><mark>关系模型</mark></strong>：以关系（二维表格形式）表示数据，是目前最常用的数据模型。</p><ul><li><p><strong>关系</strong>：一张表。</p></li><li><p><strong>关系模式</strong>：对关系结构的描述。 关系名（属性1，属性2， …，属性n ）</p><p>​e.g. 学生（学号，姓名，年龄，性别，系，年级）</p></li></ul><p>​数据操作是集合操作， 操作对象和操作结果都是关系，即若干元组的集合。</p></li></ul></li><li><p><strong>物理模型</strong>： 是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。它的具体实现是DBMS的任务。</p></li></ul></li></ol><h2 id="三-数据库系统的结构"><a class="markdownIt-Anchor" href="#三-数据库系统的结构"></a> 三、数据库系统的结构</h2><ol><li><p><strong><mark>三级模式结构</mark></strong></p><img src="/2024/06/28/9bd3300d/image-20240615191648183.png" alt="image-20240615191648183" style="zoom:60%;"><p><strong>外模式 ( 子模式、用户模式  )</strong>：用户视图。</p><p>​描述用户视图，反映用户对数据的需求。</p><p>​数据库用户（ 包括应用程序员和最终用户） 使用的<u>局部数据</u>的逻辑结构和特征的描述</p><p>​数据库用户的数据视图， 是与某一应用有关的数据的逻辑表示</p><p>​安全性：每个用户只能看见和访问所对应的外模式中的数据</p><p>​模式与外模式的关系：一对多，反映了不同的用户的应用需求、看待数据的方式、 对数据保密的要求</p><p>​介于模式与应用之间</p><p><strong>模式 ( 逻辑模式 )</strong>：数据库的逻辑结构。</p><p>​数据库中<u>全体数据</u>的逻辑结构和特征（型）的描述</p><p>​所有用户的公共数据视图， 综合了所有用户的需求</p><p>​一个数据库只有一个模式</p><p>​中间层 与数据的物理存储细节和硬件环境无关</p><p><strong>内模式（存储模式）</strong>：数据的物理存储方式。</p><p>​是数据物理结构和存储方式的描述</p><p>​是数据在数据库内部的表示方式</p><p>​一个数据库只有一个内模式</p><p>外模式／模式映象 ：定义外模式与模式之间的对应关系 ，保证数据的逻辑独立性</p><p>模式／内模式映象：定义了数据全局逻辑结构与存储结构之间的对应关系，保证数据的物理独立性</p></li></ol><h2 id="四-数据库的发展历史及分类"><a class="markdownIt-Anchor" href="#四-数据库的发展历史及分类"></a> 四、数据库的发展历史及分类</h2><ol><li><p><strong>发展历史</strong>：</p><ul><li><strong>人工管理阶段 (20世纪50年代中期前)</strong>：<ul><li>数据不保存。</li><li>应用程序管理数据。</li><li>数据不共享，独立性差。</li></ul></li><li><strong>文件系统阶段 (20世纪50年代后至60年代中期)</strong>：<ul><li>数据可以长期保存。</li><li>文件系统管理数据。</li><li>数据共享性差，冗余度大。</li><li>数据独立性差。</li></ul></li><li><strong>数据库系统阶段 (60年代末至今)</strong>：<ul><li>数据结构化。</li><li>数据共享性高，冗余度低。</li><li>数据独立性高。</li><li>数据由数据库管理系统 (DBMS) 统一管理和控制。</li></ul></li></ul></li><li><p><strong>分类</strong>：</p><ul><li><strong>按数据模型分类</strong>：<ul><li>层次数据库、网状数据库、关系数据库（基于关系模型构建的数据库）、面向对象数据库、对象关系数据库。</li></ul></li><li><strong>按使用场景分类</strong>：<ul><li>事务型数据库、分析型数据库。</li></ul></li><li><strong>按分布方式分类</strong>：<ul><li>集中式数据库、分布式数据库、客户/服务器 (Client/Server) 结构、浏览器/应用服务器/数据库服务器多层结构。</li></ul></li></ul></li></ol><p><strong>《数据库原理》课程笔记：</strong></p><ol><li><a href="/2024/06/28/9bd3300d.html" title="第一章 数据库系统概述和关系模型">第一章 数据库系统概述和关系模型</a></li><li><a href="/2024/06/28/257e255e.html" title="第七章 事务处理、并发和恢复">第七章 事务处理、并发和恢复</a></li><li><a href="/2024/06/28/885ffcc2.html" title="第二章 关系模式规范化">第二章 关系模式规范化</a></li><li><a href="/2024/06/28/d9c30aa5.html" title="第五章 存储和索引技术">第五章 存储和索引技术</a></li><li><a href="/2024/06/28/49d65152.html" title="第六章 查询处理和优化">第六章 查询处理和优化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
